#!/usr/local/bin/guile -s
!#
(use-modules (ice-9 optargs))
(use-modules (ice-9 receive))
(use-modules (ice-9 regex))
(use-modules (ice-9 popen))
(use-modules (ice-9 rdelim))

(define *fragments* '())
(define* (shader-fragment name code #:key (uniforms '()))
  (set! *fragments* (cons (list name code uniforms) *fragments*)))

(define (find-fragment name)
  (let loop ((frags *fragments*))
    (if (null? frags)
        #f
        (if (string=? (car (car frags)) name)
            (car frags)
            (loop (cdr frags))))))

(define (handle-fragments code)
  (if code
      (let ((pos (string-contains code ",(use ")))
        (if pos
            (let* ((q1 (string-contains code "\"" pos))
                   (q2 (string-contains code "\"" (1+ q1)))
                   (end (string-contains code ")" q2))
                   (fragment-name (substring code (1+ q1) q2))
                   (pre (substring code 0 pos))
                   (post (substring code (1+ end)))
                   (fragment (find-fragment fragment-name)))
              (let ((new-code (string-append pre (cadr fragment) post))
                    (new-uniforms (caddr fragment)))
                (receive (newer-code newer-uniforms) (handle-fragments new-code)
                  (values newer-code (append new-uniforms newer-uniforms)))))
            (values code '())))
      (values #f '())))

(define (indent-str n accum)
  (if (= 0 n)
      accum
      (indent-str (1- n) (string-append "\t" accum))))

(define (line n str . args)
  (apply format (append (list #t (string-append (indent-str n "") str "~%")) args)))

(define (prelude name)
  (line 1 "")
  (line 1 "// shader: ~a" name)
  (line 1 ""))

(define (remove-old-shader name)
  (line 1 "curr = find_shader(\"~a\");" name)
  (line 1 "if (valid_shader_ref(curr)) {")
  (line 2     "destroy_shader(curr);")
  (line 1 "}"))
 
(define (make-shader-ll name inputs)
  (line 1 "curr = make_shader(\"~a\", ~a);" name inputs))

(define (escape-newlines string)
  (regexp-substitute/global #f "\n" string 'pre "\\n\"\n\"" 'post))

(define (add-vertex-source shader code)                 (line 1 "add_vertex_source(curr, \"~a\");" (escape-newlines code)))
(define (add-fragment-source shader code)               (line 1 "add_fragment_source(curr, \"~a\");" (escape-newlines code)))
(define (add-geometry-source shader code)               (line 1 "add_geometry_source(curr, \"~a\");" (escape-newlines code)))
(define (add-tesselation-control-source shader code)    (line 1 "add_tesselation_control_source(curr, \"~a\");" (escape-newlines code)))
(define (add-tesselation-evaluation-source shader code) (line 1 "add_tesselation_evaluation_source(curr, \"~a\");" (escape-newlines code)))
(define (add-compute-source shader code)                (line 1 "add_compute_source(curr, \"~a\");" (escape-newlines code)))

(define (add-shader-input shader name index)
  (line 1 "add_shader_input(curr, \"~a\", ~a);" name index))

(define (add-shader-uniform shader name)
  (line 1 "add_shader_uniform(curr, \"~a\");" name))

(define (compile-and-link-shader shader)
  (line 1 "compile_result = compile_and_link_shader(curr);")
  (line 1 "if (!compile_result) {")
  (line 2     "fprintf(stderr, \"SHADER ERROR\\n\");")
  (line 2     "if (vertex_shader_info_log(curr))")
  (line 3         "fprintf(stderr, \"VERTEX-LOG:\\n%s\\n\", vertex_shader_info_log(curr));")
  (line 2     "if (fragment_shader_info_log(curr))")
  (line 3         "fprintf(stderr, \"FRAGMENT-LOG:\\n%s\\n\", fragment_shader_info_log(curr));")
  (line 2     "if (geometry_shader_info_log(curr))")
  (line 3         "fprintf(stderr, \"GEOMETRY-LOG:\\n%s\\n\", geometry_shader_info_log(curr));")
  (line 2     "if (shader_info_log(curr))")
  (line 3         "fprintf(stderr, \"PROGRAM-LOG:\\n%s\\n\", shader_info_log(curr));")
  ;; missing: tesselation
  (line 1 "}"))

(define* (make-shader name #:key vertex-shader fragment-shader geometry-shader tess-control-shader tess-eval-shader compute-shader inputs uniforms)
  (prelude name)
  (remove-old-shader name)
  (receive (vert-source vert-uniforms) (handle-fragments vertex-shader)
    (receive (frag-source frag-uniforms) (handle-fragments fragment-shader)
      (receive (geom-source geom-uniforms) (handle-fragments geometry-shader)
        (receive (tcs-source tcs-uniforms) (handle-fragments tess-control-shader)
          (receive (tes-source tes-uniforms) (handle-fragments tess-eval-shader)
            (receive (compute-source compute-uniforms) (handle-fragments compute-shader)
              (let* ((addiditonal-uniforms (append vert-uniforms frag-uniforms geom-uniforms tcs-uniforms tes-uniforms))
                     (uniforms (append (if uniforms uniforms '()) addiditonal-uniforms))
               	     (shader (make-shader-ll name (if inputs (length inputs) 0))))
                (if vert-source (add-vertex-source shader vert-source))
                (if frag-source (add-fragment-source shader frag-source))
                (if geom-source (add-geometry-source shader geom-source))
                (if tcs-source (add-tesselation-control-source shader tcs-source))
                (if tes-source (add-tesselation-evaluation-source shader tes-source))
                (if compute-source (add-compute-source shader compute-source))
                (if inputs
                    (let rec ((rest inputs) (i 0))
                      (add-shader-input shader (car rest) i)
                      (if (not (null? (cdr rest)))
                          (rec (cdr rest) (1+ i)))))
                (for-each (lambda (u) 
                            ;(format #t "adding uniform ~a~%" u) 
                            (add-shader-uniform shader u)) 
                          uniforms)
                (compile-and-link-shader shader)))))))))

;; the following is actually cgls, sorry.
(define ssm-fragments #f)
(define (register-single-material-shader-fragment name code uniforms)
  (set! ssm-fragments #t)
  (line 1 "")
  (line 1 "// shader fragment: ~a" name)
  (line 1 "")
  (if (> (length uniforms) 0)
      (line 1 "strings = (char**)malloc(sizeof(char*) * ~a);" (length uniforms))
      (line 1 "strings = 0;"))
  (let loop ((U uniforms) (i 0))
    (if (not (null? U))
	(begin (line 1 "strings[~a] = \"~a\";" i (car U))
	       (loop (cdr U) (1+ i)))))
  (line 1 "register_single_material_shader_fragment(\"~a\", \"~a\", ~a, strings);" name (escape-newlines code) (length uniforms)))

;; main program

(define datadir (let* ((port (open-input-pipe "pkg-config --variable datadir libcgl"))
		       (str  (read-line port)))
		  (close-pipe port)
		  str))
  
(primitive-load (string-append datadir "/scheme/reader-extensions.scm"))
(primitive-load (string-append datadir "/scheme/cgl-init.scm"))
(line 0 "#include <string.h>")
(line 0 "#include <stdio.h>")
(line 0 "#include <stdlib.h>")
(line 0 "#include <libcgl/shader.h>")
(if ssm-fragments (line 0 "#include <libcgls/scene.h>"))
(line 0 "")
(line 0 "void load_shaders_preprocessed_from_scheme() {")
(line 1     "shader_ref curr;")
(line 1     "bool compile_result;")
(line 1     "char **strings;")
(for-each (lambda (file)
	    (line 1 "")
	    (line 1 "")
	    (line 1 "// new shader file: ~a" file)
	    (line 1 "")
	    (line 1 "")
	    (primitive-load file))
	  (cdr (command-line)))
(line 0 "}")
